use axum::{debug_handler, extract::Request, middleware::Next, response::IntoResponse, Json};
use http::{header, StatusCode};
use jsonwebtoken::{decode, Validation};
use crate::auth::login::{Claims, Keys};
use crate::models::login_user::LoginUser;
use dotenv::dotenv;
use crate::response::app_error::JWTError;

#[debug_handler()]
pub async fn authenticate_customer(Json(_req): Json<LoginUser>) -> StatusCode {
    StatusCode::OK
}

pub async fn authenticate_jwt(req: Request, next: Next) ->Result<impl IntoResponse, (StatusCode, Json<String>)> {
    dotenv().unwrap();
    let secret = std::env::var("JWT_SECRET").expect("JWT SECRET must be set!");
    let key = Keys::new(secret.as_bytes());
   
    let bearer = req.headers()
        .get(header::AUTHORIZATION)
        .and_then(|auth_header| auth_header.to_str().ok())
        .and_then(|auth_value| {
            if auth_value.starts_with("Bearer ") {
                Some(&auth_value[7..])
            } else {
                None
            }
        });

    let bearer = if bearer.is_some() {
        bearer.unwrap()
    } else {
        return Err((StatusCode::UNAUTHORIZED, Json(String::from("Couldn't find the JWT token in the AUTHORIZATION header"))));
    };
 
    println!("bearer, {:?}", bearer);
    let claims = decode::<Claims>(bearer, &key.decoding, &Validation::default())
        .map_err(|_| {
            (StatusCode::UNAUTHORIZED, String::from("Token couldn't be decoded!"))
        }).unwrap()
        .claims;
    
    let user_id = claims.id;
    println!("user_id {:?}", user_id);

    println!("token {:?}", claims);
  

    Ok((StatusCode::OK, "Hello".to_string()).into_response())
}
